using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Diagnostics;
using ModularTemplate.Common.Application.Auditing;
using ModularTemplate.Common.Application.Identity;
using ModularTemplate.Common.Domain;
using ModularTemplate.Common.Domain.Auditing;

namespace ModularTemplate.Common.Infrastructure.Auditing;

/// <summary>
/// EF Core interceptor that captures field-level changes and writes audit logs.
/// </summary>
public sealed class AuditTrailInterceptor(
    ICurrentUserService currentUserService,
    IDateTimeProvider dateTimeProvider,
    IAuditContext auditContext) : SaveChangesInterceptor
{
    public override ValueTask<InterceptionResult<int>> SavingChangesAsync(
        DbContextEventData eventData,
        InterceptionResult<int> result,
        CancellationToken cancellationToken = default)
    {
        if (eventData.Context is null)
            return base.SavingChangesAsync(eventData, result, cancellationToken);

        var auditEntries = CreateAuditEntries(eventData.Context);

        if (auditEntries.Count == 0)
            return base.SavingChangesAsync(eventData, result, cancellationToken);

        // Store entries without temporary properties
        foreach (var entry in auditEntries.Where(e => !e.HasTemporaryProperties))
        {
            eventData.Context.Set<AuditLog>().Add(entry.ToAuditLog());
        }

        return base.SavingChangesAsync(eventData, result, cancellationToken);
    }

    public override InterceptionResult<int> SavingChanges(
        DbContextEventData eventData,
        InterceptionResult<int> result)
    {
        if (eventData.Context is null)
            return base.SavingChanges(eventData, result);

        var auditEntries = CreateAuditEntries(eventData.Context);

        foreach (var entry in auditEntries.Where(e => !e.HasTemporaryProperties))
        {
            eventData.Context.Set<AuditLog>().Add(entry.ToAuditLog());
        }

        return base.SavingChanges(eventData, result);
    }

    private List<AuditEntry> CreateAuditEntries(DbContext context)
    {
        var utcNow = dateTimeProvider.UtcNow;
        var userId = currentUserService.UserId ?? Guid.Empty;
        List<AuditEntry> auditEntries = [];

        foreach (var entry in context.ChangeTracker.Entries())
        {
            // Skip non-auditable entities
            if (entry.Entity is not IAuditable)
                continue;

            // Skip AuditLog itself to prevent recursion
            if (entry.Entity is AuditLog)
                continue;

            // Skip unchanged or detached
            if (entry.State is EntityState.Unchanged or EntityState.Detached)
                continue;

            var auditEntry = new AuditEntry(entry)
            {
                UserId = userId,
                UserName = auditContext.UserName,
                TimestampUtc = utcNow,
                CorrelationId = auditContext.CorrelationId,
                TraceId = auditContext.TraceId,
                UserAgent = auditContext.UserAgent,
                Action = DetermineAction(entry)
            };

            foreach (var property in entry.Properties)
            {
                // Skip shadow properties (except foreign keys we want to track)
                if (property.Metadata.IsShadowProperty() &&
                    !property.Metadata.IsForeignKey())
                    continue;

                var propertyName = property.Metadata.Name;

                // Handle primary keys
                if (property.Metadata.IsPrimaryKey())
                {
                    if (property.IsTemporary)
                    {
                        // Key will be generated by database
                        auditEntry.TemporaryProperties.Add(property);
                    }
                    else
                    {
                        auditEntry.SetEntityId(property.CurrentValue?.ToString() ?? "");
                    }
                    continue;
                }

                var oldValue = property.OriginalValue;
                var newValue = property.CurrentValue;

                switch (entry.State)
                {
                    case EntityState.Added:
                        auditEntry.NewValues[propertyName] = newValue;
                        break;

                    case EntityState.Deleted:
                        auditEntry.OldValues[propertyName] = oldValue;
                        break;

                    case EntityState.Modified:
                        if (property.IsModified &&
                            !Equals(property.OriginalValue, property.CurrentValue))
                        {
                            auditEntry.OldValues[propertyName] = oldValue;
                            auditEntry.NewValues[propertyName] = newValue;
                            auditEntry.AffectedColumns.Add(propertyName);
                        }
                        break;
                }
            }

            // Only add if there are actual changes to record
            if (auditEntry.OldValues.Count > 0 ||
                auditEntry.NewValues.Count > 0 ||
                entry.State == EntityState.Deleted)
            {
                auditEntries.Add(auditEntry);
            }
        }

        return auditEntries;
    }

    private static AuditAction DetermineAction(EntityEntry entry)
    {
        if (entry.State == EntityState.Added)
            return AuditAction.Insert;

        if (entry.State == EntityState.Deleted)
            return AuditAction.Delete;

        if (entry.State == EntityState.Modified)
        {
            // Check for soft delete transition
            var isDeletedProp = entry.Properties
                .FirstOrDefault(p => p.Metadata.Name.Equals(
                    "IsDeleted", StringComparison.OrdinalIgnoreCase));

            if (isDeletedProp is not null)
            {
                var wasDeleted = isDeletedProp.OriginalValue as bool? ?? false;
                var isDeleted = isDeletedProp.CurrentValue as bool? ?? false;

                if (!wasDeleted && isDeleted)
                    return AuditAction.SoftDelete;

                if (wasDeleted && !isDeleted)
                    return AuditAction.Restore;
            }

            return AuditAction.Update;
        }

        return AuditAction.Unknown;
    }
}
